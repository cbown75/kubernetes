---
apiVersion: v1
kind: Namespace
metadata:
  name: traefik-system
  labels:
    app.kubernetes.io/name: traefik
    app.kubernetes.io/part-of: traefik
    network-policy/traefik: "true"

---
apiVersion: source.toolkit.fluxcd.io/v1beta2
kind: HelmRepository
metadata:
  name: traefik
  namespace: flux-system
spec:
  interval: 24h
  url: https://traefik.github.io/charts

---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: traefik
  namespace: flux-system
spec:
  targetNamespace: traefik-system

  # Optional: keep your deps
  dependsOn:
    - name: sealed-secrets
      namespace: kube-system
    - name: metallb
      namespace: flux-system

  interval: 10m
  timeout: 10m

  chart:
    spec:
      chart: traefik
      # Use a current v3 chart (example: 37.x). Pin what you’ve tested.
      version: "37.0.0"
      sourceRef:
        kind: HelmRepository
        name: traefik
        namespace: flux-system
      interval: 5m

  # If you do NOT use the optional traefik-crds chart, keep CRDs managed here:
  install:
    createNamespace: true
    crds: CreateReplace
    remediation:
      retries: 3
  upgrade:
    crds: CreateReplace
    remediation:
      retries: 3
  rollback:
    recreate: true
    force: true

  values:
    # ---- Deployment / scheduling ----
    deployment:
      kind: Deployment
      replicas: 2
      annotations:
        reloader.stakater.com/auto: "true"
      strategy:
        type: RollingUpdate
        rollingUpdate: { maxSurge: 1, maxUnavailable: 0 }

    # ---- Service (MetalLB) ----
    service:
      enabled: true
      type: LoadBalancer
      annotations:
        metallb.universe.tf/address-pool: default
      externalTrafficPolicy: Local

    # ---- IngressClass ----
    ingressClass:
      enabled: true
      isDefaultClass: true
      name: traefik

    # ---- Providers ----
    providers:
      kubernetesCRD:
        enabled: true
        allowCrossNamespace: false
        allowExternalNameServices: false
        allowEmptyServices: false
      kubernetesIngress:
        enabled: true
        allowExternalNameServices: false
        allowEmptyServices: false
        # Let Traefik publish the LB service for status
        publishedService:
          enabled: true
          pathOverride: "traefik-system/traefik"

    # ---- EntryPoints / Ports (including metrics) ----
    ports:
      web:
        port: 8000
        expose: { default: true }
        exposedPort: 80
        protocol: TCP
        redirections:
          entryPoint: { to: websecure, scheme: https, permanent: true }
      websecure:
        port: 8443
        expose: { default: true }
        exposedPort: 443
        protocol: TCP
        tls:
          enabled: true
      traefik:
        port: 9000
        expose: { default: false }
        exposedPort: 9000
        protocol: TCP
      metrics:
        port: 9100
        expose: { default: false }
        exposedPort: 9100
        protocol: TCP

    # ---- API & dashboard ----
    api:
      dashboard: true
      debug: false
      insecure: false

    ingressRoute:
      dashboard:
        enabled: true
        matchRule: PathPrefix(`/dashboard`) || PathPrefix(`/api`)
        entryPoints: ["traefik"]
        middlewares: []
        tls: {}

    # ---- Security contexts ----
    securityContext:
      capabilities: { drop: [ALL], add: [NET_BIND_SERVICE] }
      readOnlyRootFilesystem: true
      runAsUser: 65532
      runAsGroup: 65532
      runAsNonRoot: true
    podSecurityContext:
      fsGroup: 65532
      fsGroupChangePolicy: "OnRootMismatch"
      runAsUser: 65532
      runAsGroup: 65532
      runAsNonRoot: true

    # ---- Logs ----
    logs:
      general: { level: ERROR, format: json }
      access:
        enabled: false
        format: json

    # ---- Persistence (optional; remove if you don’t want it) ----
    persistence:
      enabled: true
      name: data
      accessMode: ReadWriteMany
      size: 5Gi
      storageClass: "nfs-holocron-general"
      path: /data

    # ---- Metrics (Prometheus) ----
    metrics:
      prometheus:
        # Prom endpoint on entryPoint "metrics" (port 9100 above)
        entryPoint: metrics
        addEntryPointsLabels: true
        addServicesLabels: true
        addRoutersLabels: false
        buckets: [0.1, 0.3, 1.2, 5.0]

        # Service that exposes /metrics (ClusterIP)
        service:
          enabled: true

        # ServiceMonitor for kube-prometheus-stack
        serviceMonitor:
          enabled: true
          additionalLabels:
            release: prometheus-stack # <-- change if your stack uses a different selector
            app.kubernetes.io/part-of: monitoring-stack
          namespace: "monitoring" # where your Prometheus Operator watches
          jobLabel: "traefik"
          interval: 30s
          honorLabels: true
          metricRelabelings: []
          relabelings: []

        # PrometheusRule is intentionally disabled to avoid empty-spec errors.
        # If you want alerts, set enabled: true and provide rule groups.
        prometheusRule:
          enabled: false
          additionalLabels: {}
          namespace: "monitoring"
          rules: [] # supply valid groups if you enable this

    # ---- TLS defaults (optional) ----
    tlsOptions:
      default:
        minVersion: VersionTLS12
        sniStrict: true

    # ---- Global args ----
    globalArguments:
      - "--global.checknewversion=false"
      - "--global.sendanonymoususage=false"
